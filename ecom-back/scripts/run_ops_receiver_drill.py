#!/usr/bin/env python3
"""
Run weekly ops receiver drill for Alertmanager routing.

Modes:
- verify-only: validate required configuration only
- fire-alerts: validate config and push synthetic warning/critical alerts
"""

from __future__ import annotations

import json
import os
import urllib.request
from datetime import datetime, timedelta, timezone
from pathlib import Path


def env(name: str, default: str = "") -> str:
    return (os.getenv(name) or default).strip()


def post_alerts(alertmanager_url: str, token: str, payload: list[dict]) -> tuple[bool, str]:
    url = alertmanager_url.rstrip("/") + "/api/v2/alerts"
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(url=url, method="POST", data=data)
    req.add_header("Content-Type", "application/json")
    req.add_header("User-Agent", "ecom-ops-receiver-drill/1.0")
    if token:
        req.add_header("Authorization", f"Bearer {token}")
    try:
        with urllib.request.urlopen(req, timeout=20) as response:
            if 200 <= response.status < 300:
                return True, f"http_{response.status}"
            return False, f"http_{response.status}"
    except Exception as ex:  # noqa: BLE001
        return False, f"{type(ex).__name__}: {ex}"


def build_alert_payload(run_id: str, starts_at: str, ends_at: str) -> list[dict]:
    base_annotations = {
        "summary": "Synthetic receiver routing drill",
        "description": "Generated by weekly ops-receiver drill workflow.",
        "runbook": "ecom-back/infrastructure/runbooks/ALERT_DRILL.md",
    }
    return [
        {
            "labels": {
                "alertname": "OpsReceiverDrillWarning",
                "severity": "warning",
                "service": "payment-service",
                "component": "ops-drill",
                "drill": "weekly",
                "runId": run_id,
            },
            "annotations": base_annotations,
            "startsAt": starts_at,
            "endsAt": ends_at,
            "generatorURL": "https://github.com",
        },
        {
            "labels": {
                "alertname": "OpsReceiverDrillCritical",
                "severity": "critical",
                "service": "payment-service",
                "component": "ops-drill",
                "drill": "weekly",
                "runId": run_id,
            },
            "annotations": base_annotations,
            "startsAt": starts_at,
            "endsAt": ends_at,
            "generatorURL": "https://github.com",
        },
    ]


def main() -> int:
    mode = env("OPS_RECEIVER_DRILL_MODE", "fire-alerts")
    run_id = env("GITHUB_RUN_ID", "local")
    alertmanager_api_url = env("ALERTMANAGER_API_URL")
    alertmanager_api_token = env("ALERTMANAGER_API_BEARER_TOKEN")
    slack_payment_channel = env("ALERTMANAGER_SLACK_CHANNEL_PAYMENT")
    slack_critical_channel = env("ALERTMANAGER_SLACK_CHANNEL_CRITICAL")
    pd_payment_key = env("ALERTMANAGER_PD_ROUTING_KEY_PAYMENT")
    pd_critical_key = env("ALERTMANAGER_PD_ROUTING_KEY_CRITICAL")

    out_dir = Path(env("CALIBRATION_OUTPUT_DIR", "build-artifacts"))
    out_dir.mkdir(parents=True, exist_ok=True)

    checks = [
        ("ALERTMANAGER_API_URL", bool(alertmanager_api_url)),
        ("ALERTMANAGER_SLACK_CHANNEL_PAYMENT", bool(slack_payment_channel)),
        ("ALERTMANAGER_SLACK_CHANNEL_CRITICAL", bool(slack_critical_channel)),
        ("ALERTMANAGER_PD_ROUTING_KEY_PAYMENT", bool(pd_payment_key)),
        ("ALERTMANAGER_PD_ROUTING_KEY_CRITICAL", bool(pd_critical_key)),
    ]
    missing = [name for name, ok in checks if not ok]

    fire_attempted = mode == "fire-alerts"
    fire_success = False
    fire_detail = "skipped"
    starts_at = datetime.now(timezone.utc)
    ends_at = starts_at + timedelta(minutes=15)
    if fire_attempted and not missing:
        payload = build_alert_payload(
            run_id=run_id,
            starts_at=starts_at.isoformat().replace("+00:00", "Z"),
            ends_at=ends_at.isoformat().replace("+00:00", "Z"),
        )
        fire_success, fire_detail = post_alerts(alertmanager_api_url, alertmanager_api_token, payload)

    passed = len(missing) == 0 and (not fire_attempted or fire_success)
    report = {
        "generatedAt": datetime.now(timezone.utc).isoformat(),
        "mode": mode,
        "runId": run_id,
        "checks": [{"name": name, "ok": ok} for name, ok in checks],
        "missing": missing,
        "fireAttempted": fire_attempted,
        "fireSuccess": fire_success,
        "fireDetail": fire_detail,
        "status": "passed" if passed else "failed",
    }

    json_path = out_dir / "ops-receiver-drill-report.json"
    md_path = out_dir / "ops-receiver-drill-report.md"
    json_path.write_text(json.dumps(report, indent=2), encoding="utf-8")

    lines = [
        "# Ops Receiver Drill Report",
        "",
        f"Generated at: {report['generatedAt']}",
        f"Mode: `{mode}`",
        f"Run ID: `{run_id}`",
        "",
        "| Check | Status |",
        "|---|---|",
    ]
    for check in report["checks"]:
        lines.append(f"| {check['name']} | {'ok' if check['ok'] else 'missing'} |")
    lines.extend(
        [
            "",
            f"- Fire attempted: `{str(fire_attempted).lower()}`",
            f"- Fire success: `{str(fire_success).lower()}`",
            f"- Fire detail: `{fire_detail}`",
            f"- Final status: `{report['status']}`",
        ]
    )
    md_path.write_text("\n".join(lines) + "\n", encoding="utf-8")

    print(f"Wrote {json_path}")
    print(f"Wrote {md_path}")
    return 0 if passed else 1


if __name__ == "__main__":
    raise SystemExit(main())
